Netty对Reactor的支持 源码角度

Netty如何支持主从Reactor模式的？
为什么Netty的main reactor大多不能用到一个线程组，只能线程组里的一个
Netty给Channel分配nio loop event 的规则是什么
通用模式的nio实现多路复用器怎么跨平台的

bossGroup是main reactor
workerGroup是sub reactor
group.register(channel) channel指的是ServerSocketChannel
将ServerSocketChannel绑定到了bossGroup

group(bossGroup, workerGroup);
源码查看方式：构造方法，得到group，Alt+F7看谁read了这个方法，有个group()方法
然后看group方法的调用，鼠标放到方法上，ctrl+Alt+H，找到initAndRegister方法
ChannelFuture regFuture = config().group().register(channel);
拿到了group，将channel绑定到了bossGroup （ServerSocketChannel）
ServerSocketChannel就可以创建子的socketChannel，绑定到创建的workerGroup上
ChannelRead

两种socketChannel绑定到两个group中，完成了主从reactor的模式

跨平台实现源码

给channel分配NioEventLoop的时候，根据不同的情况选择不同的算法

粘包半包概念 ABC DEF ABCDEF , AB CD EF

为什么TCP会出现
发送方每次写入数据<套接字缓冲区大小  每次写入数据小，网卡不会立马发送，合并发送，粘包
接收方读取套接字缓冲区数据不够及时 对方读取数据不及时，发送方发送数据大于MTU，必须拆包，发多次， 是个半包

收发角度:一个发送可能多次接收，多个发送可能一次接收
传输角度：一个发送可能占用多个传输包，多个发送可能公用一个传输包
TCP是流式协议，消息无边界
UDP没有粘包半包 接收一个一个接收

解决方案：
固定字段存储内容长度信息   固定长度浪费空间，分隔符需要扫描内容

常用解决方法
Netty对三种常用封帧方式的支持
Netty处理粘包半包的源码