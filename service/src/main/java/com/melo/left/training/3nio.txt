端口是什么？
用来区分通信的时候知道是哪个服务


单线程处理Socket
每个请求一个线程
固定大小线程池处理
 服务员线程

单线程处理Socket
每个请求一个线程
固定大小线程池处理

存在两种类型操作
CPU计算、业务处理
IO操作与等待/网络、磁盘、数据库

Socket通信模型
建立连接
开始通信
结束通信

建立服务端通信Socket
等待并接收连接请求

创建连接Socket并向服务端发起请求

接收请求后创建连接Socket

InputStream OutputStream

关闭Socket相关资源（服务端和客户端都有）

为什么创建比CPU核心数多的线程？
有Sleep操作，等待处理，不消耗CPU
加入创建的线程数只有核心的CPU数的话，那么线程是吃不饱的，CPU占用被释放了，没有别的线程来
接，这样CPU资源就浪费掉了。不是所有的线程都在忙或者干活，有些员工摸鱼，所以有更多的员工干事。

对于一个IO相关应用来说，通过网络访问读取本地文件再返回给客户端，
大部分CPU使用的非常少，等资源可能就被浪费了。
分工协调上下文切换，所以需要统筹，
GC并发收集的时候，不影响业务线程 并行处理的多一些

不仅面临CPU、线程的问题，还有数据来回复制的问题
用户空间、内核空间

线程的等待导致CPU使用率不高、创建更多的线程导致了竞争，底层Socket操作更复杂，有很多资源消耗，这
就涉及到IO的模型，通信模型

阻塞、非阻塞 是线程处理模式
同步、异步 是通信模式 线程要不要拦住

		阻塞		非阻塞
同步   阻塞IO模型   非阻塞IO模型
       IO复用模型   信号驱动IO模型
异步                异步IO模型

基本上都是同步的

发起者的线程和处理结果的线程不是一个线程
叫人去买东西，自己做自己的事情，同步非阻塞。两个线程在做，把结果告诉我，不是当前线程做，背后有异步的线程池去做
在发起的线程看来是同步操作，但是比以前快了，有其他线程在帮助做，future.get()


分布式事务，都是靠时钟来保证的