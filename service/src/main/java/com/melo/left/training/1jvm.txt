GC 垃圾回收  内存管理器
静态类型 编译执行 面向对象
编译好的字节码是跨平台，二进制的跨平台，作为一个统一的文件分发到不同系统
C++却不行，它是源代码跨平台
Java的兼容性比较好

编程语言有两种，一种是被人骂的，一种是没人用的。

字节码的作用：研究代码细节，找到写法不同的根本原因 相当于汇编语言
字节码由单字节byte的指令组成，理论上最多支持256个操作码，opcode，实际上只使用了200左右。

根据指令的性质，分为四大类
栈操作，包括与局部变量交互的指令
程序流控制，跳转，if，for循环
对象操作，包括方法调用指令
算数运算、类型抓换

生成字节码 main方法中new一个当前类
$ javap -c HelloByteCode.class
Compiled from "HelloByteCode.java"
public class com.melo.left.training.java.HelloByteCode {
  public com.melo.left.training.java.HelloByteCode();
    Code:
       0: aload_0                     助记符，相当于字节码的操作码      a：引用
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V 调用方法Object的初始化方法
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: new           #2                  // class com/melo/left/training/java/HelloByteCode
       3: dup 复制栈 dump
       4: invokespecial #3                  // Method "<init>":()V
       7: astore_1
       8: return
}

aload astore
JVM中都是基于栈的操作，还有个本地变量表，所有的计算都是在栈上，变量的名字和值在本地变量表，怎么计算呢？
在运行的时候，把变量挪到栈上，运行完后把栈上的值store回本地变量表，需要load store基本操作
                LOAD->
LOCAL VARIABLE           STACK
                <-STORE


$ javap -c -verbose HelloByteCode.class
Classfile /E:/code/left/service/target/classes/com/melo/left/training/java/Hello                                                                                  ByteCode.class
  Last modified 2021-11-29; size 474 bytes
  MD5 checksum 1e202864c36154ebc6a96d019aebd519
  Compiled from "HelloByteCode.java"
public class com.melo.left.training.java.HelloByteCode
  minor version: 0
  major version: 52  //JVM版本号
  flags: ACC_PUBLIC, ACC_SUPER //类是public or其他
Constant pool: //常量池 引用到所有的变量 在操作栈上都是一个数字
   #1 = Methodref          #4.#19         // java/lang/Object."<init>":()V
   #2 = Class              #20            // com/melo/left/training/java/HelloBy                                                                                  teCode
   #3 = Methodref          #2.#19         // com/melo/left/training/java/HelloBy                                                                                  teCode."<init>":()V
   #4 = Class              #21            // java/lang/Object
   #5 = Utf8               <init>
   #6 = Utf8               ()V
   #7 = Utf8               Code
   #8 = Utf8               LineNumberTable
   #9 = Utf8               LocalVariableTable
  #10 = Utf8               this
  #11 = Utf8               Lcom/melo/left/training/java/HelloByteCode;
  #12 = Utf8               main
  #13 = Utf8               ([Ljava/lang/String;)V
  #14 = Utf8               args
  #15 = Utf8               [Ljava/lang/String;
  #16 = Utf8               object
  #17 = Utf8               SourceFile
  #18 = Utf8               HelloByteCode.java
  #19 = NameAndType        #5:#6          // "<init>":()V
  #20 = Utf8               com/melo/left/training/java/HelloByteCode
  #21 = Utf8               java/lang/Object
{
  public com.melo.left.training.java.HelloByteCode();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>                                                                                  ":()V
         4: return
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/melo/left/training/java/HelloByteCode;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1          //创建深度为几栈深度 本地变量表长度多少，几个槽位 一切都可控
         0: new           #2                  // class com/melo/left/training/ja                                                                                  va/HelloByteCode
         3: dup
         4: invokespecial #3                  // Method "<init>":()V
         7: astore_1
         8: return
      LineNumberTable:
        line 5: 0
        line 6: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  args   [Ljava/lang/String;
            8       1     1 object   Lcom/melo/left/training/java/HelloByteCode;
}
SourceFile: "HelloByteCode.java"

当定义一个布尔类型的变量，字节码实际上是当做int类型处理的，32位是字节码处理的最小单位
int32 long64 原子性问题  64位操作系统都是原子性操作，32位系统不是

a+b 两种不同类型 在编译时字节码已经做好了相关的转换指令，jvm执行很快

方法调用的指令
invokestatic 调用某类的静态方法，最快的调用指令
invokespecial 调用构造函数，也可同一个类的private方法，可见的超类方法
invokevirtual 具体类型目标对象，调用公共、受保护和package级的私有方法 ，被子类覆盖的父类方法，实际调用的是子类的方法这就是虚方法 只要有子类覆盖
invokeinterface 接口引用调用方法时
invokedynamic JDK新加，实现动态类型语言支持，JDK8以后支持lambda实现基础

不同的classloader可以做版本化，模块化。两个兄弟没有任何的双亲关系，基于这个可以把不同的jar包隔离掉
同样的代码用两个classloader加载，代码加接口升级了，用B loader加载，代码有了两个不同版本的类，这是
JDK9之前会出现的自定义类加载器

扩展类和应用类可见,启动类是c++实现的看不到

堆上没有计算能力，只有栈有计算能力。
每个线程的局部变量副本是独立的

每启动一个线程，JVM就会在栈空间 分配 对应的线程栈 如1MB空间Xss

线程栈也就Java方法栈，如果使用了JNI方法，会分配一个单独的本地方法栈 Native Stack

线程执行过程中，会有多个方法组成调用栈，StackTrace 比如A调用B，B调用C... 每执行到一个方法就会创建对应的栈帧 Frame

栈帧包含返回值 局部变量表 操作数栈 CLassMethod指针，可以看做一个小的虚拟机
线程栈下有多个栈帧
JVM栈下有多个线程栈
JVM进程下包含 栈 堆 非堆 JVM自身，  堆最大-Xmx1G，一般为物理内存的70%以下

堆外内存可以用到跟堆一样的内存

调用JNI方法时会产生方法栈，内存不在JVM的管理方位之内，也是在堆外内存

栈帧是一个逻辑上的概念，具体的大小在一个方法编写完成后基本就能确定。

jps -lmv
               1s打一次  执行1000次
jstat -gc pid 1000 1000
jstat -gcutil pid 1000 1000 更简洁，每秒显示各个区大小，回收时间

ps -ef | grep java

jmap -heap pid  简单的堆配置

jmap -histo pid 占用排名
instances 实例 占用字节 className   [B [I [L类
[C is a char[]  和字符串相关
[S is a short[]
[I is a int[]
[B is a byte[]
[[I is a int[][]

jmap -histo pid > a.txt
vim a.txt

输入 gg 命令，光标会移动到文档开头 ；
输入 G 命令，光标会移动到文档末尾；

jstack -l pid
将线程相关的locks信息一起输出，比如持有的锁，等待 的锁
parking to wait for <>
kill -3 pid

kill -3 PID命令只能打印那一瞬间java进程的堆栈信息，适合在服务器响应慢，cpu、内存快速飙升等异常情况下使用，
可以方便地定位到导致异常发生的java类，解决如死锁、连接超时等原因导致的系统异常问题。该命令不会杀死进程。

jcmd pid help
jcmd pid VM.version
jcmd pid VM.flags
jcmd pid VM.info  记录了最近发生的GC的情况 GC Heap History (20 Events)
jcmd pid GC.heap_info

jrunscript -e "cat("http://www.baidu.com")"

堆 默认的配置是什么

jconsole
堆内存一直上升不下降，有问题

jvisualvm
Visual GC
jmc

引用计数 循环依赖的对象，永远不会为0，最终导致内存溢出
一旦为0，就不会变为1了
所以引出了 引用跟踪， 不去标记所有的对象了，对象生存时间短，从根对象出发扫描遍历标记，没有标记的就是死对象
循环的问题也解决了，不用扫描那么多的对象

标记清除上百万个对象，STW

堆包括新生代和老年代，新生代Young包括Eden，S1,S1，默认比例8:1:1.

标记阶段Eden区存活的对象就会复制到存活区，为什么不是移动呢？ 新生代大部分对象都是要被回收的
整理老年代空间内容，将所有存活的对象复制，从老年代开始的地方依次存放，因为老年代小部分是被回收，大部分是存活的

8之后Meta在非堆

根对象：当前正在执行的方法里的局部变量和输入参数
活动线程
所有类的静态字段
JNI引用

年轻代和老年代GC分开，根对象各自是各自的GC ROOTS
对象从新生到老年，有些引用关系还在新生代，老年代引用到了新生代，需要单独的集合记录跨代的引用关系GC ROOTS即Rset RememberSet
在处理新生代 就是Rset + 新生代GC ROOTS

暂停时间与堆大小，对象总数没直接关系，而是由存活对象的数量决定，存活的数量少，STW短 增加堆内存大小不会直接影响标记阶段占用的时间

Young GC非常快 存活对象少 STW短暂

标记清除
内存会有碎片

标记复制  ：年轻代存货的少，用这个比较好
占用空间

标记 清除 整理 ： 老年代用比较好 移动节省内存
多了整理，大范围挪动对象，慢

G1到了45%开始做GC

S1 S0的数据不会放到Eden

敲黑板，各种GC

演示
java -jar -XX:+UseParallelGC -XX:+UseParallelOldGC  .\service-1.0-SNAPSHOT.jar
-XX:+UseParallelGC
-XX:+UseParallelOldGC
jmap -heap pid