GC 垃圾回收  内存管理器
静态类型 编译执行 面向对象
编译好的字节码是跨平台，二进制的跨平台，作为一个统一的文件分发到不同系统
C++却不行，它是源代码跨平台
Java的兼容性比较好

编程语言有两种，一种是被人骂的，一种是没人用的。

字节码的作用：研究代码细节，找到写法不同的根本原因 相当于汇编语言
字节码由单字节byte的指令组成，理论上最多支持256个操作码，opcode，实际上只使用了200左右。

根据指令的性质，分为四大类
栈操作，包括与局部变量交互的指令
程序流控制，跳转，if，for循环
对象操作，包括方法调用指令
算数运算、类型抓换

生成字节码 main方法中new一个当前类
$ javap -c HelloByteCode.class
Compiled from "HelloByteCode.java"
public class com.melo.left.training.java.HelloByteCode {
  public com.melo.left.training.java.HelloByteCode();
    Code:
       0: aload_0                     助记符，相当于字节码的操作码      a：引用
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V 调用方法Object的初始化方法
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: new           #2                  // class com/melo/left/training/java/HelloByteCode
       3: dup 复制栈 dump
       4: invokespecial #3                  // Method "<init>":()V
       7: astore_1
       8: return
}

aload astore
JVM中都是基于栈的操作，还有个本地变量表，所有的计算都是在栈上，变量的名字和值在本地变量表，怎么计算呢？
在运行的时候，把变量挪到栈上，运行完后把栈上的值store回本地变量表，需要load store基本操作
                LOAD->
LOCAL VARIABLE           STACK
                <-STORE


$ javap -c -verbose HelloByteCode.class
Classfile /E:/code/left/service/target/classes/com/melo/left/training/java/Hello                                                                                  ByteCode.class
  Last modified 2021-11-29; size 474 bytes
  MD5 checksum 1e202864c36154ebc6a96d019aebd519
  Compiled from "HelloByteCode.java"
public class com.melo.left.training.java.HelloByteCode
  minor version: 0
  major version: 52  //JVM版本号
  flags: ACC_PUBLIC, ACC_SUPER //类是public or其他
Constant pool: //常量池 引用到所有的变量 在操作栈上都是一个数字
   #1 = Methodref          #4.#19         // java/lang/Object."<init>":()V
   #2 = Class              #20            // com/melo/left/training/java/HelloBy                                                                                  teCode
   #3 = Methodref          #2.#19         // com/melo/left/training/java/HelloBy                                                                                  teCode."<init>":()V
   #4 = Class              #21            // java/lang/Object
   #5 = Utf8               <init>
   #6 = Utf8               ()V
   #7 = Utf8               Code
   #8 = Utf8               LineNumberTable
   #9 = Utf8               LocalVariableTable
  #10 = Utf8               this
  #11 = Utf8               Lcom/melo/left/training/java/HelloByteCode;
  #12 = Utf8               main
  #13 = Utf8               ([Ljava/lang/String;)V
  #14 = Utf8               args
  #15 = Utf8               [Ljava/lang/String;
  #16 = Utf8               object
  #17 = Utf8               SourceFile
  #18 = Utf8               HelloByteCode.java
  #19 = NameAndType        #5:#6          // "<init>":()V
  #20 = Utf8               com/melo/left/training/java/HelloByteCode
  #21 = Utf8               java/lang/Object
{
  public com.melo.left.training.java.HelloByteCode();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>                                                                                  ":()V
         4: return
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/melo/left/training/java/HelloByteCode;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: new           #2                  // class com/melo/left/training/ja                                                                                  va/HelloByteCode
         3: dup
         4: invokespecial #3                  // Method "<init>":()V
         7: astore_1
         8: return
      LineNumberTable:
        line 5: 0
        line 6: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  args   [Ljava/lang/String;
            8       1     1 object   Lcom/melo/left/training/java/HelloByteCode;
}
SourceFile: "HelloByteCode.java"

当定义一个布尔类型的变量，字节码实际上是当做int类型处理的，32位是字节码处理的最小单位
int32 long64 原子性问题  64位操作系统都是原子性操作，32位系统不是

a+b 两种不同类型 在编译时字节码已经做好了相关的转换指令，jvm执行很快

方法调用的指令
invokestatic 调用某类的静态方法，最快的调用指令
invokespecial 调用构造函数，也可同一个类的private方法，可见的超类方法
invokevirtual 具体类型目标对象，调用公共、受保护和package级的私有方法
invokeinterface 接口引用调用方法时
invokedynamic JDK新加，实现动态类型语言支持，JDK8以后支持lambda实现基础