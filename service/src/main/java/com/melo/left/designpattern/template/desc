模板模式主要是用来解决复用和扩展两个问题。
我们今天会结合 Java Servlet、JUnit TestCase、Java InputStream、Java AbstractList
四个例子来具体讲解这两个作用。

模板模式作用一：复用
模板模式把一个算法中不变的流程抽象到父类的模板方法 templateMethod() 中，
将可变的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现。

Java IO 类库中，有很多类的设计用到了模板模式，比如 InputStream、OutputStream、Reader、Writer。

在 Java AbstractList 类中，addAll() 函数可以看作模板方法，add() 是子类需要重写的方法，
尽管没有声明为 abstract 的，但函数实现直接抛出了 UnsupportedOperationException 异常。

public boolean addAll(int index, Collection<? extends E> c) {
    rangeCheckForAdd(index);
    boolean modified = false;
    for (E e : c) {
        add(index++, e);
        modified = true;
    }
    return modified;
}

public void add(int index, E element) {
    throw new UnsupportedOperationException();
}
模板模式作用二：扩展
扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似我们之前讲到的控制反转，
基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，
定制化框架的功能。我们通过 Junit TestCase、Java Servlet


public class HelloServlet extends HttpServlet {
  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    this.doPost(req, resp);
  }

  @Override
  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    resp.getWriter().write("Hello World.");
  }
}