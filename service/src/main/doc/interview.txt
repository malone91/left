硬：
spring循环依赖描述和解决方案
事务隔离级别
bean生命周期和作用域
mvc和spring容器
beanfactory和factorybean区别
怎么实现可重复读的，如何保证一致性
mysql有哪些日志，如何做数据同步
介绍一下索引
mysql有哪些锁
mysql字节大小问题
sql优化方案
B+树结构
join联表原理
突然不走索引了，为什么？
redis雪崩，击穿，穿透，解决方案
redis分布式，槽
redis有哪些优化，比如string，hash
redis有哪些数据结构，redis内部数据结构
redis应用场景 gossip协议
jvm默认垃圾回收器，回收算法，回收过程jvm调优经验，各种gc过程，默认gc
加载机制，破坏双亲委派 普通的对象会被分配到TLAB上
字节码操纵技术:ASM Javassist cglib 字节码到Java对象的转换
介绍一下HTTP的头有哪些参数
mybatis一级、二级、三级缓存
springboot的启动过程，与spring的区别
dubbo原理
dubbo序列化方式
dubbo负载均衡策略
dubbo是什么？
微服务的理解，springcloud是什么？
mongo索引
实现一个跳表
链表 各种排序
层序遍历，前中后序遍历
动态规划，回文串，中心扩展法
tcp与udp区别
HTTP HTTPS HTTP3 HTTP2
介绍一下netty
mq介绍一下原理，消息如何不丢失
select，poll，epoll区别
springboot如何读取各个环境的
线程池的原理
线程池的一个线程抛出异常怎么办
ThreadLocal源码
并发包
说一下AQS
锁
happen-before原则
设计模式
线程的状态
string stringbuffer stringbuilder区别
aop原理
hashmap和concurrentHashMap源码 hashmap默认大小，初始化大小是多少/
java并行流的原理
监控服务器CPU 内存 磁盘 IO的命令
linux命令，日志分析关键字出现次数
手写一个cron
拦截器、过滤器区别
zk分布式协议

所有的项目都要自己看一遍代码，理解作者的意图
转换为短地址
链表部分反转
多线程打印ABCABC
进程间通信：共享内存 信号量 Socket 管道 消息 信号
安全发布 双检测，可能导致未完整初始化的对象被访问
死锁活锁饥饿
DDD
springmvc的适配器模式，设计模式，好处 mvc单独一个容器吗

软：职业规划，为什么离职，期待薪资，如何学习

模拟压测，多线程，jprofile

统计字符串出现的次数
cat aaa.log | grep "JedisMovedDataException" | wc -l
当前WEB服务器中联接次数最多的ip地址
netstat -ntu | awk '{print $5}' |sort | uniq -c| sort -nr
查看日志中访问次数最多的前10个IP
cat access_log | cut -d ' ' -f 1 | sort |uniq -c | sort -nr | awk '{print $0 }' | head -n 10 | less
cat  t1.log | sort

ocqs list
位的与或运算
cron
@Scheduled(cron = "0 0 * * * ?")
@SchedulerLock(name = "scanBlockedSubCommitContractJob", lockAtMostFor = lockMaxTime, lockAtLeastFor = lockMaxTime)

索引失效，解决办法

starter原理
只需要引入官方提供的starter, 就可以直接使用, 免去了各种配置,
原因在于spring-boot的自动发现,比如当classpath下面有tomcat-embedded.jar 时,
对应的bean就会被加载.

oom原因
实现一个本地线程变量

dubbo扩展,aop打日志
@Activate(group = Constants.PROVIDER, order = -999)
public class DubboTraceFilter implements Filter{
    private static final Logger logger = LoggerFactory.getLogger(DubboTraceFilter.class);
    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
        try {
            FilterDesc filterReq = new FilterDesc() ;
            filterReq.setInterfaceName(invocation.getInvoker().getInterface().getName());
            filterReq.setMethodName(invocation.getMethodName()) ;
            filterReq.setArgs(invocation.getArguments());
            logger.debug("dubbo请求数据:"+JSON.toJSONString(filterReq));
            Result result = invoker.invoke(invocation);
            if (result.hasException() && invoker.getInterface() != GenericService.class){
                logger.error("dubbo执行异常",result.getException());
            }else {
                logger.info("dubbo执行成功");
                FilterDesc filterRsp = new FilterDesc() ;
                filterRsp.setMethodName(invocation.getMethodName());
                filterRsp.setInterfaceName(invocation.getInvoker().getInterface().getName());
                filterRsp.setArgs(new Object[]{result.getValue()});
                logger.debug("dubbo返回数据"+JSON.toJSONString(filterRsp));
            }
            return result ;
        }catch (RuntimeException e){
            logger.error("dubbo未知异常" + RpcContext.getContext().getRemoteHost()
                    + ". service: " + invoker.getInterface().getName() + ", method: " + invocation.getMethodName()
                    + ", exception: " + e.getClass().getName() + ": " + e.getMessage(), e);
            throw e ;
        }
    }
}

springbot扩展点

redis删除过程 集群模式 https://www.cnblogs.com/51life/p/10233340.html
主从复制，哨兵模式和集群
1支持主从复制，主机会自动将数据同步到从机，可以进行读写分离
2当主服务器中断服务后，可以将一个从服务器升级为主服务器，以便继续提供服务，但是这个过程需要人工手动来操作。
为此，Redis 2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。
3redis的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存，
所以在redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。

mongo集群模式
分片是数据跨多台机器存储，MongoDB使用分片来支持具有非常大的数据集和高吞吐量操作的部署，
MongoDB支持通过分片进行水平扩展，多台服务器
主从复制（Master-Slaver）、副本集（Replica Set）和分片（Sharding）模式。
Master-Slaver 是一种主从副本的模式，目前已经不推荐使用。
Replica Set 模式取代了 Master-Slaver 模式，是一种互为主从的关系。Replica Set 将数据复制多份保存，不同服务器保存同一份数据，在出现故障时自动切换，实现故障转移，在实际生产中非常实用。
Sharding 模式适合处理大量数据，它将数据分开存储，不同服务器保存不同的数据，所有服务器数据的总和即为整个数据集。

Springcloud组件
服务发现——Netflix Eureka
客服端负载均衡——Netflix Ribbon
断路器——Netflix Hystrix
服务网关——Netflix Zuul
分布式配置——Spring Cloud Config

走格子
消息丢失
状态机实现

多线程，JVM
ThreadLocal原理，使用场景
JVM CPU100%
ArrayList 线程不安全，数组越界异常
HashMap为什么不安全，出现环形链表
ConcurrentHashMap 7 8锁的不同
NIO，buffer的方法 selector，channel
类加载器
AQS原理
CountDownLatch原理
Redis处理缓存击穿，默认值并设置短期的存活时间，定时器加载
多路复用
可重入锁

mysql死锁，如何避免
存放元素的数组，容量永远是2的N次方
元素存放在数组中的索引位置，实际是 hash 对数组容量进行取余
之所以是等效于取余，是因为 hash 的尾部与 1 做 & 运算会保持原来的值

resize() 造成死循环
参考 ：疫苗：JAVA HASHMAP的死循环

其实，这个问题在 JDK1.8 已经被修复了 。死循环的原因是 resize() 时链表的倒序引起的，
但是在 JDK1.8 中，插入元素并会再插入链表头部了，resize() 时也不会倒排了。