对于限流框架的几个要求：
    易用性：基于内存的单机限流算法，基于Redis的分布式限流算法，能方便集成到Spring框架中
    扩展性、灵活性：支持各种限流算法，不同格式，不同数据源
    性能：接口服务比较敏感
    容错性：如果挂掉了怎么办？

    基本的功能性需求其实没有多少，但是考虑到非功能性需求明显复杂了很多，
    写出能用的代码很简单，写出好用的代码很难。

    易用，灵活，可扩展，低延迟，高容错，才是开发的重点。

    Sentinel

    三步走：分析，设计，实战
    系统设计，划分模块
    限流规则，限流算法，限流模式，集成使用4个模块

    最小惊奇原则
    尽管越细的时间粒度限流整形效果越好，流量曲线越平滑，但也并不是时间粒度越小越合适。

    常见的限流算法有：
    固定时间窗口限流算法、滑动时间窗口限流算法、令牌桶限流算法、漏桶限流算法。
    其中，固定时间窗口限流算法最简单。
    我们只需要选定一个起始时间起点，之后每来一个接口请求，我们都给计数器
    （记录当前时间窗口内的访问次数）加一，如果在当前时间窗口内，
    根据限流规则（比如每秒钟最大允许 100 次接口请求），
    累加访问次数超过限流值（比如 100 次），就触发限流熔断，拒绝接口请求。
    当进入下一个时间窗口之后，计数器清零重新计数。
    记录在当前时间窗口内已经被访问的次数
    这种算法的限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量：
    假设一秒100，第一秒内0 0 0 0 0 0 0 0 0 1，第二秒内1 0 0 0 0 0 0 0 0 0
    1代表100次，那么20毫秒内有200次，可能会压垮系统。

    为了让流量更加平滑，有了更加高级的滑动时间窗口限流算法、令牌桶限流算法、漏桶限流算法

    考虑到框架的扩展性，我们需要预先做好设计，预留好扩展点，
    方便今后扩展其他限流算法。
    除此之外，为了提高框架的易用性、灵活性，我们最好将其他几种常用的限流算法，
    也在框架中实现出来，供框架用户根据自己业务场景自由选择。

    限流模式：单机限流和分布式限流

    限流过程中会频繁地查询接口对应的限流规则，为了尽可能地提高查询速度，
    我们需要将限流规则组织成一种支持按照 URL 快速查询的数据结构。
    考虑到 URL 的重复度比较高，
    且需要按照前缀来匹配，我们这里选择使用 Trie 树这种数据结构

    限制任意时间窗口（比如 1s）内，接口请求数都不能超过某个阈值（ 比如 100 次）。
    因此，相对于固定时间窗口限流算法，这个算法叫滑动时间窗口限流算法。

    我们假设限流的规则是，在任意 1s 内，接口的请求次数都不能大于 K 次。我们就维护一个大小为 K+1 的循环队列，
    用来记录 1s 内到来的请求。注意，这里循环队列的大小等于限流次数加一，
    因为循环队列存储数据时会浪费一个存储单元。当有新的请求到来时，我们将与这个新请求的时间间隔超过 1s 的请求，
    从队列中删除。然后，我们再来看循环队列中是否有空闲位置。如果有，则把新请求存储在队列尾部（tail 指针所指的位置）；
    如果没有，则说明这 1 秒内的请求次数已经超过了限流值 K，所以这个请求被拒绝服务。

    基于时间窗口的限流算法，不管是固定时间窗口还是滑动时间窗口，只能在选定的时间粒度上限流，
    对选定时间粒度内的更加细粒度的访问频率不做限制。

    https://time.geekbang.org/column/article/97231 RateLimiter